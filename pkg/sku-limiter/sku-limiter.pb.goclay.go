// Code generated by protoc-gen-goclay. DO NOT EDIT.
// source: sku-limiter.proto

/*
Package skulimiter is a self-registering gRPC and JSON+Swagger service definition.

It conforms to the github.com/utrack/clay/v2/transport Service interface.
*/
package skulimiter

import (
	"bytes"
	"context"
	"encoding/base64"
	"fmt"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"

	"github.com/go-chi/chi"
	"github.com/go-openapi/spec"
	"github.com/grpc-ecosystem/grpc-gateway/runtime"
	"github.com/grpc-ecosystem/grpc-gateway/utilities"
	"github.com/pkg/errors"
	"github.com/utrack/clay/v2/transport"
	"github.com/utrack/clay/v2/transport/httpclient"
	"github.com/utrack/clay/v2/transport/httpruntime"
	"github.com/utrack/clay/v2/transport/httpruntime/httpmw"
	"github.com/utrack/clay/v2/transport/httptransport"
	"github.com/utrack/clay/v2/transport/swagger"
	"google.golang.org/grpc"
)

// Update your shared lib or downgrade generator to v1 if there's an error
var _ = transport.IsVersion2

var _ = ioutil.Discard
var _ chi.Router
var _ runtime.Marshaler
var _ bytes.Buffer
var _ context.Context
var _ fmt.Formatter
var _ strings.Reader
var _ errors.Frame
var _ httpruntime.Marshaler
var _ http.Handler
var _ url.Values
var _ base64.Encoding
var _ httptransport.MarshalerError
var _ utilities.DoubleArray

// SKULimiterDesc is a descriptor/registrator for the SKULimiterServer.
type SKULimiterDesc struct {
	svc  SKULimiterServer
	opts httptransport.DescOptions
}

// NewSKULimiterServiceDesc creates new registrator for the SKULimiterServer.
// It implements httptransport.ConfigurableServiceDesc as well.
func NewSKULimiterServiceDesc(svc SKULimiterServer) *SKULimiterDesc {
	return &SKULimiterDesc{
		svc: svc,
	}
}

// RegisterGRPC implements service registrator interface.
func (d *SKULimiterDesc) RegisterGRPC(s *grpc.Server) {
	RegisterSKULimiterServer(s, d.svc)
}

// Apply applies passed options.
func (d *SKULimiterDesc) Apply(oo ...transport.DescOption) {
	for _, o := range oo {
		o.Apply(&d.opts)
	}
}

// SwaggerDef returns this file's Swagger definition.
func (d *SKULimiterDesc) SwaggerDef(options ...swagger.Option) (result []byte) {
	if len(options) > 0 || len(d.opts.SwaggerDefaultOpts) > 0 {
		var err error
		var s = &spec.Swagger{}
		if err = s.UnmarshalJSON(_swaggerDef_sku_limiter_proto); err != nil {
			panic("Bad swagger definition: " + err.Error())
		}

		for _, o := range d.opts.SwaggerDefaultOpts {
			o(s)
		}
		for _, o := range options {
			o(s)
		}
		if result, err = s.MarshalJSON(); err != nil {
			panic("Failed marshal spec.Swagger definition: " + err.Error())
		}
	} else {
		result = _swaggerDef_sku_limiter_proto
	}
	return result
}

// RegisterHTTP registers this service's HTTP handlers/bindings.
func (d *SKULimiterDesc) RegisterHTTP(mux transport.Router) {
	chiMux, isChi := mux.(chi.Router)

	{
		// Handler for CreateLimitSKU, binding: POST /create-limit-sku
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_SKULimiter_CreateLimitSKU_0(r)
			rsp, err := _SKULimiter_CreateLimitSKU_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_SKULimiter_CreateLimitSKU_0, h)
		} else {
			mux.Handle(pattern_goclay_SKULimiter_CreateLimitSKU_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetLimitSKU, binding: POST /get-limit-sku
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_SKULimiter_GetLimitSKU_0(r)
			rsp, err := _SKULimiter_GetLimitSKU_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_SKULimiter_GetLimitSKU_0, h)
		} else {
			mux.Handle(pattern_goclay_SKULimiter_GetLimitSKU_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for DelLimitSKU, binding: POST /del-limit-sku
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_SKULimiter_DelLimitSKU_0(r)
			rsp, err := _SKULimiter_DelLimitSKU_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_SKULimiter_DelLimitSKU_0, h)
		} else {
			mux.Handle(pattern_goclay_SKULimiter_DelLimitSKU_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for AddOrder, binding: POST /add-order
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_SKULimiter_AddOrder_0(r)
			rsp, err := _SKULimiter_AddOrder_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_SKULimiter_AddOrder_0, h)
		} else {
			mux.Handle(pattern_goclay_SKULimiter_AddOrder_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetLimitUserSKUs, binding: POST /get-limit-user-skus
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_SKULimiter_GetLimitUserSKUs_0(r)
			rsp, err := _SKULimiter_GetLimitUserSKUs_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_SKULimiter_GetLimitUserSKUs_0, h)
		} else {
			mux.Handle(pattern_goclay_SKULimiter_GetLimitUserSKUs_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for GetLimitUsersActions, binding: POST /get-limit-users-actions
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_SKULimiter_GetLimitUsersActions_0(r)
			rsp, err := _SKULimiter_GetLimitUsersActions_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_SKULimiter_GetLimitUsersActions_0, h)
		} else {
			mux.Handle(pattern_goclay_SKULimiter_GetLimitUsersActions_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for ReturnOrder, binding: POST /return-order
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_SKULimiter_ReturnOrder_0(r)
			rsp, err := _SKULimiter_ReturnOrder_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_SKULimiter_ReturnOrder_0, h)
		} else {
			mux.Handle(pattern_goclay_SKULimiter_ReturnOrder_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

	{
		// Handler for DelLimitUser, binding: POST /del-limit-user
		var h http.HandlerFunc
		h = http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
			defer r.Body.Close()

			unmFunc := unmarshaler_goclay_SKULimiter_DelLimitUser_0(r)
			rsp, err := _SKULimiter_DelLimitUser_Handler(d.svc, r.Context(), unmFunc, d.opts.UnaryInterceptor)

			if err != nil {
				if err, ok := err.(httptransport.MarshalerError); ok {
					httpruntime.SetError(r.Context(), r, w, errors.Wrap(err.Err, "couldn't parse request"))
					return
				}
				httpruntime.SetError(r.Context(), r, w, err)
				return
			}

			if ctxErr := r.Context().Err(); ctxErr != nil && ctxErr == context.Canceled {
				w.WriteHeader(499) // Client Closed Request
				return
			}

			_, outbound := httpruntime.MarshalerForRequest(r)
			w.Header().Set("Content-Type", outbound.ContentType())
			err = outbound.Marshal(w, rsp)
			if err != nil {
				httpruntime.SetError(r.Context(), r, w, errors.Wrap(err, "couldn't write response"))
				return
			}
		})

		h = httpmw.DefaultChain(h)

		if isChi {
			chiMux.Method("POST", pattern_goclay_SKULimiter_DelLimitUser_0, h)
		} else {
			mux.Handle(pattern_goclay_SKULimiter_DelLimitUser_0, http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
				if r.Method != "POST" {
					w.WriteHeader(http.StatusMethodNotAllowed)
					return
				}
				h(w, r)
			}))
		}
	}

}

type SKULimiter_httpClient struct {
	c    *http.Client
	host string
}

// NewSKULimiterHTTPClient creates new HTTP client for SKULimiterServer.
// Pass addr in format "http://host[:port]".
func NewSKULimiterHTTPClient(c *http.Client, addr string) *SKULimiter_httpClient {
	if strings.HasSuffix(addr, "/") {
		addr = addr[:len(addr)-1]
	}
	return &SKULimiter_httpClient{c: c, host: addr}
}

func (c *SKULimiter_httpClient) CreateLimitSKU(ctx context.Context, in *CLRequest, opts ...grpc.CallOption) (*CLResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_SKULimiter_CreateLimitSKU_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := CLResponse{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *SKULimiter_httpClient) GetLimitSKU(ctx context.Context, in *GLRequest, opts ...grpc.CallOption) (*GLResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_SKULimiter_GetLimitSKU_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := GLResponse{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *SKULimiter_httpClient) DelLimitSKU(ctx context.Context, in *DLRequest, opts ...grpc.CallOption) (*DLResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_SKULimiter_DelLimitSKU_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := DLResponse{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *SKULimiter_httpClient) AddOrder(ctx context.Context, in *AORequest, opts ...grpc.CallOption) (*AOResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_SKULimiter_AddOrder_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := AOResponse{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *SKULimiter_httpClient) GetLimitUserSKUs(ctx context.Context, in *GLUSRequest, opts ...grpc.CallOption) (*GLUSResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_SKULimiter_GetLimitUserSKUs_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := GLUSResponse{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *SKULimiter_httpClient) GetLimitUsersActions(ctx context.Context, in *GLUARequest, opts ...grpc.CallOption) (*GLUAResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_SKULimiter_GetLimitUsersActions_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := GLUAResponse{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *SKULimiter_httpClient) ReturnOrder(ctx context.Context, in *RORequest, opts ...grpc.CallOption) (*ROResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_SKULimiter_ReturnOrder_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := ROResponse{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

func (c *SKULimiter_httpClient) DelLimitUser(ctx context.Context, in *DLURequest, opts ...grpc.CallOption) (*DLUResponse, error) {
	mw, err := httpclient.NewMiddlewareGRPC(opts)
	if err != nil {
		return nil, err
	}

	path := pattern_goclay_SKULimiter_DelLimitUser_0_builder(in)

	buf := bytes.NewBuffer(nil)

	m := httpruntime.DefaultMarshaler(nil)

	if err = m.Marshal(buf, in); err != nil {
		return nil, errors.Wrap(err, "can't marshal request")
	}

	req, err := http.NewRequest("POST", c.host+path, buf)
	if err != nil {
		return nil, errors.Wrap(err, "can't initiate HTTP request")
	}
	req = req.WithContext(ctx)

	req.Header.Add("Accept", m.ContentType())

	req, err = mw.ProcessRequest(req)
	if err != nil {
		return nil, err
	}
	rsp, err := c.c.Do(req)
	if err != nil {
		return nil, errors.Wrap(err, "error from client")
	}
	defer rsp.Body.Close()

	rsp, err = mw.ProcessResponse(rsp)
	if err != nil {
		return nil, err
	}

	if rsp.StatusCode >= 400 {
		b, _ := ioutil.ReadAll(rsp.Body)
		return nil, errors.Errorf("%v %v: server returned HTTP %v: '%v'", req.Method, req.URL.String(), rsp.StatusCode, string(b))
	}

	ret := DLUResponse{}

	err = m.Unmarshal(rsp.Body, &ret)

	return &ret, errors.Wrap(err, "can't unmarshal response")
}

// patterns for SKULimiter
var (
	pattern_goclay_SKULimiter_CreateLimitSKU_0 = "/create-limit-sku"

	pattern_goclay_SKULimiter_CreateLimitSKU_0_builder = func(in *CLRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/create-limit-sku"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_SKULimiter_CreateLimitSKU_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_SKULimiter_GetLimitSKU_0 = "/get-limit-sku"

	pattern_goclay_SKULimiter_GetLimitSKU_0_builder = func(in *GLRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/get-limit-sku"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_SKULimiter_GetLimitSKU_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_SKULimiter_DelLimitSKU_0 = "/del-limit-sku"

	pattern_goclay_SKULimiter_DelLimitSKU_0_builder = func(in *DLRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/del-limit-sku"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_SKULimiter_DelLimitSKU_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_SKULimiter_AddOrder_0 = "/add-order"

	pattern_goclay_SKULimiter_AddOrder_0_builder = func(in *AORequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/add-order"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_SKULimiter_AddOrder_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_SKULimiter_GetLimitUserSKUs_0 = "/get-limit-user-skus"

	pattern_goclay_SKULimiter_GetLimitUserSKUs_0_builder = func(in *GLUSRequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/get-limit-user-skus"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_SKULimiter_GetLimitUserSKUs_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_SKULimiter_GetLimitUsersActions_0 = "/get-limit-users-actions"

	pattern_goclay_SKULimiter_GetLimitUsersActions_0_builder = func(in *GLUARequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/get-limit-users-actions"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_SKULimiter_GetLimitUsersActions_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_SKULimiter_ReturnOrder_0 = "/return-order"

	pattern_goclay_SKULimiter_ReturnOrder_0_builder = func(in *RORequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/return-order"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_SKULimiter_ReturnOrder_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}

	pattern_goclay_SKULimiter_DelLimitUser_0 = "/del-limit-user"

	pattern_goclay_SKULimiter_DelLimitUser_0_builder = func(in *DLURequest) string {
		values := url.Values{}

		u := url.URL{
			Path:     fmt.Sprintf("/del-limit-user"),
			RawQuery: values.Encode(),
		}
		return u.String()
	}

	unmarshaler_goclay_SKULimiter_DelLimitUser_0_boundParams = &utilities.DoubleArray{Encoding: map[string]int{"": 0}, Base: []int{1, 1, 0}, Check: []int{0, 1, 2}}
)

// marshalers for SKULimiter
var (
	unmarshaler_goclay_SKULimiter_CreateLimitSKU_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*CLRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_SKULimiter_CreateLimitSKU_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_SKULimiter_GetLimitSKU_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*GLRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_SKULimiter_GetLimitSKU_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_SKULimiter_DelLimitSKU_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*DLRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_SKULimiter_DelLimitSKU_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_SKULimiter_AddOrder_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*AORequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_SKULimiter_AddOrder_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_SKULimiter_GetLimitUserSKUs_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*GLUSRequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_SKULimiter_GetLimitUserSKUs_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_SKULimiter_GetLimitUsersActions_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*GLUARequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_SKULimiter_GetLimitUsersActions_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_SKULimiter_ReturnOrder_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*RORequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_SKULimiter_ReturnOrder_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}

	unmarshaler_goclay_SKULimiter_DelLimitUser_0 = func(r *http.Request) func(interface{}) error {
		return func(rif interface{}) error {
			req := rif.(*DLURequest)

			if err := errors.Wrap(runtime.PopulateQueryParameters(req, r.URL.Query(), unmarshaler_goclay_SKULimiter_DelLimitUser_0_boundParams), "couldn't populate query parameters"); err != nil {
				return httpruntime.TransformUnmarshalerError(err)
			}

			inbound, _ := httpruntime.MarshalerForRequest(r)
			if err := errors.Wrap(inbound.Unmarshal(r.Body, &req), "couldn't read request JSON"); err != nil {
				return httptransport.NewMarshalerError(httpruntime.TransformUnmarshalerError(err))
			}

			return nil
		}
	}
)

var _swaggerDef_sku_limiter_proto = []byte(`{
  "swagger": "2.0",
  "info": {
    "title": "sku-limiter.proto",
    "version": "version not set"
  },
  "schemes": [
    "http",
    "https"
  ],
  "consumes": [
    "application/json"
  ],
  "produces": [
    "application/json"
  ],
  "paths": {
    "/add-order": {
      "post": {
        "operationId": "AddOrder",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/skulimiterAOResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/skulimiterAORequest"
            }
          }
        ],
        "tags": [
          "SKULimiter"
        ]
      }
    },
    "/create-limit-sku": {
      "post": {
        "operationId": "CreateLimitSKU",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/skulimiterCLResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/skulimiterCLRequest"
            }
          }
        ],
        "tags": [
          "SKULimiter"
        ]
      }
    },
    "/del-limit-sku": {
      "post": {
        "operationId": "DelLimitSKU",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/skulimiterDLResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/skulimiterDLRequest"
            }
          }
        ],
        "tags": [
          "SKULimiter"
        ]
      }
    },
    "/del-limit-user": {
      "post": {
        "operationId": "DelLimitUser",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/skulimiterDLUResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/skulimiterDLURequest"
            }
          }
        ],
        "tags": [
          "SKULimiter"
        ]
      }
    },
    "/get-limit-sku": {
      "post": {
        "operationId": "GetLimitSKU",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/skulimiterGLResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/skulimiterGLRequest"
            }
          }
        ],
        "tags": [
          "SKULimiter"
        ]
      }
    },
    "/get-limit-user-skus": {
      "post": {
        "operationId": "GetLimitUserSKUs",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/skulimiterGLUSResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/skulimiterGLUSRequest"
            }
          }
        ],
        "tags": [
          "SKULimiter"
        ]
      }
    },
    "/get-limit-users-actions": {
      "post": {
        "operationId": "GetLimitUsersActions",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/skulimiterGLUAResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/skulimiterGLUARequest"
            }
          }
        ],
        "tags": [
          "SKULimiter"
        ]
      }
    },
    "/return-order": {
      "post": {
        "operationId": "ReturnOrder",
        "responses": {
          "200": {
            "description": "A successful response.",
            "schema": {
              "$ref": "#/definitions/skulimiterROResponse"
            }
          }
        },
        "parameters": [
          {
            "name": "body",
            "in": "body",
            "required": true,
            "schema": {
              "$ref": "#/definitions/skulimiterRORequest"
            }
          }
        ],
        "tags": [
          "SKULimiter"
        ]
      }
    }
  },
  "definitions": {
    "GLUAResponseSKUs": {
      "type": "object",
      "properties": {
        "skus": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/skulimiterGLUAResponseLimit"
          }
        }
      }
    },
    "skulimiterAORequest": {
      "type": "object",
      "properties": {
        "userId": {
          "type": "integer",
          "format": "int32"
        },
        "orderId": {
          "type": "integer",
          "format": "int32"
        },
        "orderTs": {
          "type": "string",
          "format": "int64"
        },
        "content": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/skulimiterAORequestSKU"
          }
        }
      },
      "title": "ADD Order USER"
    },
    "skulimiterAORequestSKU": {
      "type": "object",
      "properties": {
        "sku": {
          "type": "string"
        },
        "marketingActionId": {
          "type": "string"
        },
        "qty": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "skulimiterAOResponse": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string"
        }
      }
    },
    "skulimiterCLRequest": {
      "type": "object",
      "properties": {
        "skus": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/skulimiterCLRequestActions"
          }
        }
      },
      "title": "CREATE Limit SKU"
    },
    "skulimiterCLRequestAction": {
      "type": "object",
      "properties": {
        "limit": {
          "type": "integer",
          "format": "int32"
        },
        "sec": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "skulimiterCLRequestActions": {
      "type": "object",
      "properties": {
        "actions": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/skulimiterCLRequestAction"
          }
        }
      }
    },
    "skulimiterCLResponse": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string"
        }
      }
    },
    "skulimiterDLRequest": {
      "type": "object",
      "properties": {
        "skus": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "actions": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "title": "DEL Limit SKU"
    },
    "skulimiterDLResponse": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string"
        }
      }
    },
    "skulimiterDLURequest": {
      "type": "object",
      "properties": {
        "users": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "actions": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "title": "DEL Limit USER"
    },
    "skulimiterDLUResponse": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string"
        }
      }
    },
    "skulimiterGLRequest": {
      "type": "object",
      "properties": {
        "skus": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "actions": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "title": "GET Limit SKU"
    },
    "skulimiterGLResponse": {
      "type": "object",
      "properties": {
        "skus": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/skulimiterGLResponseActions"
          }
        }
      }
    },
    "skulimiterGLResponseAction": {
      "type": "object",
      "properties": {
        "limit": {
          "type": "integer",
          "format": "int32"
        },
        "sec": {
          "type": "string",
          "format": "int64"
        },
        "datestart": {
          "type": "string",
          "format": "int64"
        }
      }
    },
    "skulimiterGLResponseActions": {
      "type": "object",
      "properties": {
        "actions": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/skulimiterGLResponseAction"
          }
        }
      }
    },
    "skulimiterGLUARequest": {
      "type": "object",
      "properties": {
        "users": {
          "type": "array",
          "items": {
            "type": "string"
          }
        },
        "actions": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "title": "GET Limit USERS actions"
    },
    "skulimiterGLUAResponse": {
      "type": "object",
      "properties": {
        "users": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/GLUAResponseSKUs"
          }
        }
      }
    },
    "skulimiterGLUAResponseLimit": {
      "type": "object",
      "properties": {
        "limit": {
          "type": "object",
          "additionalProperties": {
            "type": "integer",
            "format": "int32"
          }
        }
      }
    },
    "skulimiterGLUSRequest": {
      "type": "object",
      "properties": {
        "userId": {
          "type": "string"
        },
        "skus": {
          "type": "array",
          "items": {
            "type": "string"
          }
        }
      },
      "title": "GET Limit USER SKUs"
    },
    "skulimiterGLUSResponse": {
      "type": "object",
      "properties": {
        "userId": {
          "type": "string"
        },
        "sku": {
          "type": "object",
          "additionalProperties": {
            "$ref": "#/definitions/skulimiterGLUSResponseLimit"
          }
        }
      }
    },
    "skulimiterGLUSResponseLimit": {
      "type": "object",
      "properties": {
        "limit": {
          "type": "object",
          "additionalProperties": {
            "type": "integer",
            "format": "int32"
          }
        }
      }
    },
    "skulimiterRORequest": {
      "type": "object",
      "properties": {
        "userId": {
          "type": "integer",
          "format": "int32"
        },
        "orderId": {
          "type": "integer",
          "format": "int32"
        },
        "returnTs": {
          "type": "string",
          "format": "int64"
        },
        "content": {
          "type": "array",
          "items": {
            "$ref": "#/definitions/skulimiterRORequestSKU"
          }
        }
      },
      "title": "RETURN (возврат) order USER"
    },
    "skulimiterRORequestSKU": {
      "type": "object",
      "properties": {
        "sku": {
          "type": "string"
        },
        "qty": {
          "type": "integer",
          "format": "int32"
        }
      }
    },
    "skulimiterROResponse": {
      "type": "object",
      "properties": {
        "status": {
          "type": "string"
        }
      }
    }
  }
}

`)
